function outpairs=pair_filter(inpairs,chan_locs,type,arg)

n_pairs=size(inpairs,1);
n_chans=length(chan_locs);

switch type
    case 'x_edge'
        
        exclude_channels=[1 2 3 4 14 15 26 27 30 31 32 33 36 37 38 46 45 54 55 58];
        exclude_pairs=any(ismember(inpairs,exclude_channels),2);
        outpairs=inpairs(~exclude_pairs,:);
        
    case 'distance'
        
        if ~isnumeric(arg)
            error('For distance filter, arg must be [lower upper] in cm')
            return
        end
        
        pair_distance=zeros(n_pairs,1);
        for p=1:n_pairs
            x_dist = chan_locs(inpairs(p,1)).X - chan_locs(inpairs(p,2)).X;
            y_dist = chan_locs(inpairs(p,1)).Y - chan_locs(inpairs(p,2)).Y;
            z_dist = chan_locs(inpairs(p,1)).Z - chan_locs(inpairs(p,2)).Z;
            pair_distance(p) = sqrt( x_dist^2 + y_dist^2 + z_dist^2 );
        end
        
        if length(arg)==2
        
        arg = arg / 10; %convert from cm to dm
        distance_inds = pair_distance > arg(1) & pair_distance < arg(2);
        
        elseif length(arg)==1
        
        %determine subsets by distance
        mean_distance = mean(pair_distance);
        std_distance = std(pair_distance);

        switch arg
            case 1 % 1 = very near
                distance_inds = pair_distance < mean_distance - std_distance;
            case 2 % 2 = lower middle distance (mean-std, mean)
                distance_inds = pair_distance > mean_distance - std_distance & pair_distance < mean_distance;
            case 3 % 2 = middle distance (mean-std, mean+std)
                distance_inds = pair_distance < mean_distance + std_distance & pair_distance > mean_distance - std_distance;
            case 4 % 3 = upper middle distance (mean,mean+std)
                distance_inds = pair_distance > mean_distance & pair_distance < mean_distance + std_distance;
            case 5 % 4 = very distant
                distance_inds = pair_distance > mean_distance + std_distance;
        end
            
        end
        
        outpairs=inpairs(distance_inds,:);
        
    case 'angle'
        
        %determine the angle of the chosen pairs
        pair_angle=zeros(n_pairs,1);
        for p=1:n_pairs
            %define [x1 x2], [y1 y2]
            x=[chan_locs(inpairs(p,1)).topo_x chan_locs(inpairs(p,2)).topo_x];
            y=[chan_locs(inpairs(p,1)).topo_y chan_locs(inpairs(p,2)).topo_y];
            pair_angle(p)=atan((y(2)-y(1))/(x(2)-x(1)));
        end
        
        oriented_inds = pair_angle < -1.26 | ( pair_angle > -0.314 & pair_angle < 0.314 ) | pair_angle > 1.26 ;
        ap_inds = pair_angle < -1.26 | pair_angle > 1.26 ;
        lr_inds = pair_angle > -0.314 & pair_angle < 0.314;
        %take the subset of non-nearly a-p or l-r oriented pairs
        non_oriented_inds = ~oriented_inds;
        switch arg
            case 'ap'
                outpairs = inpairs(ap_inds,:);
            case 'lr'
                outpairs = inpairs(lr_inds,:);
            case 'aplr' %take the a-p or l-r oriented pairs
                outpairs = inpairs(oriented_inds,:);
            case 'diag' %take the diagonally-oriented pairs
                outpairs = inpairs(non_oriented_inds,:);
        end
        
    case 'max_degree'
        
        unique_chans=unique(inpairs)';
        degree=zeros(n_chans,1);
        %this algorithm removes pairs until the degree is reduced to a certain
        %number
        for chan=unique_chans
        p=0;
        while p<=length(inpairs)-1
            p=p+1;
            if any(inpairs(p,:)==chan)
                degree(chan)=degree(chan)+1;
            end
            if degree(chan)>arg
                if any(inpairs(p,:)==chan)
                    inpairs(p,:)=[];
                    p=p-1;
                end
            end
        end
        end
        outpairs=inpairs;
        
    case 'hemispheric'
        
        hemi_relation=zeros(n_pairs,1);
        % if y coord is positive, left, if y coord is negative, right
        for p=1:n_pairs
            if sign(chan_locs(inpairs(p,1)).Y) && sign(chan_locs(inpairs(p,2)).Y) % if pairs have the same sign (both on left, both on right)
                hemi_relation(p) = 1; % 1 means intra hemispheric
            elseif sign(chan_locs(inpairs(p,1)).Y)==0 && sign(chan_locs(inpairs(p,2)).Y)==0 % if both pairs are at 0 (on midline)
                hemi_relation(p) = 3; % 3 means neither
            else
                hemi_relation(p) = 2;
            end
        end
        
        
        switch arg
            case 'inter'
                
            case 'intra'
                
        end
        
    end
    
    
end